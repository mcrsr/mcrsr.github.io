<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <title>REST API</title>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
    <!-- Font Awesome icons (free version)-->
    <script src="https://use.fontawesome.com/releases/v6.1.0/js/all.js" crossorigin="anonymous"></script>
    <!-- Google fonts-->
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet"
        type="text/css" />
    <link
        href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css" />
    <!-- Core theme CSS (includes Bootstrap)-->
    <link href="css/styles.css" rel="stylesheet" />
</head>

<body>
    <!-- Navigation-->
    <nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
        <div class="container px-4 px-lg-5">
            <a class="navbar-brand" href="index.html">MCRSR</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive"
                aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                Menu
                <i class="fas fa-bars"></i>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ms-auto py-4 py-lg-0">
                    <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="index.html">Home</a></li>
                    <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="about.html">About</a></li>
                    <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="post.html">Sample Post</a></li>
                    <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="contact.html">Contact</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- Page Header-->
    <header class="masthead" style="background-image: url('images/API.webp')">
        <div class="container position-relative px-4 px-lg-5">
            <div class="row gx-4 gx-lg-5 justify-content-center">
                <div class="col-md-10 col-lg-8 col-xl-7">
                    <div class="post-heading">
                        <h1>REST API</h1>
                        <h2 class="subheading">REST API</h2>
                        <span class="meta">
                            Posted by
                            <a href="#!">Start Bootstrap</a>
                            on August 24, 2022
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </header>
    <!-- Post Content-->
    <article class="mb-4">
        <div class="container px-4 px-lg-5">
            <div class="row gx-4 gx-lg-5 justify-content-center">
                <div class="col-md-10 col-lg-8 col-xl-7">

                    <div id="client_server">
                        <h1>Client & Server</h1>
                        <p>In the context of software, the terms "client" and "server" refer to different parts of a distributed computing system. A distributed computing system is a network of computers that work together to perform a specific task or provide a service. In this system, the client and server are two separate entities that communicate with each other to accomplish their respective tasks.</p>
                        <h6>Client</h6>
                        <p>A client is a piece of software that runs on a user's computer or device and interacts with a server to obtain information or perform an action. The client sends requests to the server, which responds with the requested information or action. The client can be a web browser, a mobile app, or a desktop application. Clients are often designed to provide a user interface for interacting with the server and presenting the results to the user in a user-friendly manner.</p>
                        <h6>Server</h6>
                        <p>A server, on the other hand, is a computer program or device that provides a service or resource to other computers or devices on the network. Servers typically run continuously in the background and listen for requests from clients. When a request is received, the server processes it and sends a response back to the client. Servers can be dedicated hardware devices, virtual machines, or even software programs running on a desktop computer.</p>
                        <p>The communication between a client and server is usually done using a protocol such as HTTP, TCP/IP, or FTP. The client sends a request to the server using this protocol, and the server responds with the requested information or action. The client and server can communicate with each other over a local network or over the internet.</p>
                        <h6>Client-server architecture</h6>
                        <img src="./images/Client-server-model.png" alt="api testing" width="100%">
                        <p>Client-server architecture is a type of distributed computing architecture in which the client software interacts with the server software to access services or resources. In this architecture, the client and server software run on different machines and communicate with each other over a network.</p>
                        <p>The client-server architecture consists of two main components: the client and the server. The client is the front-end component that runs on the user's machine and interacts with the user to obtain input and display results. The server is the back-end component that runs on a dedicated machine and provides services or resources to clients.</p>
                        <p>The client sends requests to the server, and the server responds with the requested information or action. The server is responsible for managing and storing data, performing computations, and providing services to clients. The client is responsible for presenting the information or results obtained from the server to the user in a user-friendly manner.</p>
                        <p>There are different types of client-server architectures, including two-tier, three-tier, and n-tier architectures. In a two-tier architecture, the client communicates directly with the server, while in a three-tier architecture, an intermediate layer is added between the client and server. The intermediate layer is responsible for processing requests, managing data, and providing security. In an n-tier architecture, multiple layers are added between the client and server to provide more scalability, flexibility, and modularity.</p>
                        <img src="./images/Client-server-model-3-tier.png" alt="api testing" width="100%">
                        <p>Some advantages of the client-server architecture include:</p>
                        <ul>
                            <li>Scalability: The server can handle multiple requests from different clients at the same time, allowing the system to scale as the number of clients grows.</li>
                            <li>Centralized management: All data and services are managed on the server, making it easier to manage and maintain the system.</li>
                            <li>Security: The server can enforce security policies and control access to resources, making it easier to protect data and prevent unauthorized access.</li>
                            <li>Flexibility: Different types of clients can access the same services or resources provided by the server, allowing for greater flexibility in the design of the system.</li>
                        </ul>
                    </div>

                    <div id="">
                        <h1>different types of API</h1>
                        <p>There are several types of APIs (Application Programming Interfaces) used in software development. Here are some of the most common types:</p>
                        <ul>
                            <li>REST API: REST (Representational State Transfer) is a web-based API that uses HTTP requests to retrieve and manipulate data. It is a popular choice for building web applications because it uses simple HTTP requests and responses, making it easy to understand and use.</li>
                            <li>SOAP API: SOAP (Simple Object Access Protocol) is another web-based API that uses XML to send and receive messages between applications. It is a more complex protocol than REST, but it is still widely used in enterprise environments.</li>
                            <li>GraphQL API: GraphQL is a query language for APIs that allows clients to request exactly the data they need and nothing more. It provides a more efficient way of fetching data from a server, especially when dealing with large, complex data sets.</li>
                            <li>Webhooks API: A webhook is a way for an application to notify another application when a specific event occurs. For example, when a user creates a new post on a social media platform, the platform can send a webhook to notify a third-party application that the post has been created.</li>
                            <li>Real-time APIs: Real-time APIs are used to provide real-time data to applications. Examples include APIs that provide real-time stock prices, weather information, or traffic updates.</li>
                            <li>Open APIs: Open APIs are publicly available and can be accessed by anyone. They are often used by third-party developers to build applications that integrate with other services.</li>
                            <li>Internal APIs: Internal APIs are used within a company or organization to share data and functionality between different applications or services.</li>
                        </ul>
                        <p>These are just a few examples of the types of APIs that are commonly used in software development. There are many other types of APIs, and new ones are being developed all the time to meet the changing needs of the industry.</p>
                    </div>

                    <div>
                        <h1>difference between API and web service</h1>
                        <p>API and web service are two terms that are often used interchangeably, but they are not the same thing. Here's the difference:</p>
                        <h6>API:</h6>
                        <p>API stands for Application Programming Interface. An API is a set of protocols, routines, and tools for building software applications. It defines how different components of a software application can interact with each other. In other words, an API is a way for one software application to communicate with another.</p>
                        <h6>Web Service:</h6>
                        <p>A web service is a specific type of API that is accessed over the internet using a standardized protocol such as HTTP. It is a software system designed to support interoperable machine-to-machine interaction over a network. Web services provide a way for different applications to communicate with each other, regardless of the platform, language, or operating system they are using.</p>
                        <p>The key difference between an API and a web service is the medium used for communication. While an API can be accessed over a local network or directly within an application, a web service is accessed over the internet using standardized protocols. Web services are often used to integrate disparate systems or to provide a platform-independent interface to an application. APIs, on the other hand, can be used for a variety of purposes, such as accessing data or controlling an application's functionality.</p>
                        <p><b>NOTE:</b>All webserices are APIs but not all APIs are webservices.</p>
                    </div>
                    
                    <div id="http">
                        <h1>HTTP</h1>
                        <p>HTTP stands for Hypertext Transfer Protocol. It is an application layer protocol that is used for communication between web servers and clients (such as web browsers). HTTP is the foundation of data communication on the World Wide Web.</p>
                        <p>When a client (such as a web browser) sends an HTTP request to a web server, the request is typically in the form of a URL (Uniform Resource Locator), which specifies the location of the requested resource (such as a webpage, an image, or a video). The web server processes the request and sends back an HTTP response, which typically contains the requested resource.</p>
                        <p>HTTP is a stateless protocol, which means that each request/response pair is independent of any previous request/response pairs. In other words, the web server does not maintain any state information about previous requests from a client. This makes HTTP simple and scalable, but it also means that applications that require stateful communication (such as e-commerce applications) need to use additional techniques (such as cookies or session management) to maintain state information.</p>
                        <p>HTTP is based on a client-server model, where the client (such as a web browser) sends requests to the server, and the server responds with the requested data. HTTP requests are composed of a request line, headers, and a message body (which is optional). HTTP responses are composed of a response line, headers, and a message body (which is also optional).</p>
                        <p>HTTP is a text-based protocol, which means that messages are represented using text characters (such as ASCII or Unicode). HTTP messages can be transferred using a variety of transport protocols, but the most common transport protocol used with HTTP is TCP (Transmission Control Protocol).</p>
                        <p>Overall, HTTP is a fundamental protocol for web communication, and it enables clients and servers to exchange data and resources on the World Wide Web.</p>
                        <h5>different types of http versions:</h5>
                        <p>There are several versions of HTTP that have been developed over time, including:</p>
                        <ul>
                            <li>HTTP/0.9: This was the first version of HTTP, which was released in 1991. It was a simple protocol that only supported GET requests and did not include headers.</li>
                            <li>HTTP/1.0: This version of HTTP was released in 1996 and added support for headers, allowing for more complex requests and responses. It also introduced the concept of status codes, such as 404 Not Found.</li>
                            <li>HTTP/1.1: This version of HTTP was released in 1999 and is the most widely used version of HTTP today. It introduced several new features, such as support for persistent connections, chunked encoding, and caching. It also improved performance by allowing multiple requests to be sent over a single connection.</li>
                            <li>HTTP/2: This version of HTTP was released in 2015 and is designed to improve performance by reducing latency and improving throughput. It uses a binary protocol instead of a text-based protocol, and includes features such as multiplexing, header compression, and server push.</li>
                            <li>HTTP/3: This version of HTTP is currently in development and is designed to improve performance even further by using a new transport protocol called QUIC (Quick UDP Internet Connections). QUIC is designed to reduce latency and improve reliability, especially for connections over the internet.</li>
                        </ul>
                        <p>Each version of HTTP has built upon the previous version and added new features and improvements. The most recent versions of HTTP (HTTP/2 and HTTP/3) are designed to improve performance and security for modern web applications.</p>
                    </div>
                    
                    <div>
                        <h1>difference between http and https</h1>
                        <p>HTTP and HTTPS are both protocols for communication between web servers and clients (such as web browsers), but they differ in terms of security.</p>
                        <p>HTTP (Hypertext Transfer Protocol) is an application layer protocol that is used for communication between web servers and clients. It is a text-based protocol and is not encrypted, which means that data transmitted using HTTP can be intercepted and read by attackers. For example, if you submit a form on a website using HTTP, the data you submit (such as your username and password) can be intercepted and read by an attacker.</p>
                        <p>HTTPS (Hypertext Transfer Protocol Secure) is a secure version of HTTP that uses encryption to protect data transmitted between web servers and clients. HTTPS uses the SSL/TLS protocol (Secure Sockets Layer/Transport Layer Security) to encrypt data, which means that data transmitted using HTTPS is protected from interception and reading by attackers. When you submit a form on a website using HTTPS, the data you submit is encrypted and cannot be intercepted and read by an attacker.</p>
                        <p>In addition to providing encryption, HTTPS also provides authentication and integrity protection. HTTPS uses digital certificates to verify the identity of web servers, which helps to prevent attackers from impersonating a website. HTTPS also uses message authentication codes (MACs) to ensure that data transmitted between web servers and clients has not been tampered with.</p>
                        <p>Overall, the main difference between HTTP and HTTPS is that HTTPS provides encryption to protect data transmitted between web servers and clients, while HTTP does not provide encryption and is therefore not secure for transmitting sensitive information. It is recommended that all websites use HTTPS to protect user data and ensure the security of web communication.</p>
                    </div>

                    <div>
                        <h1>URI</h1>
                        <p>URI stands for Uniform Resource Identifier. It is a string of characters that identifies a name or a resource on the Internet. A URI can be used to identify a web page, an image, a file, or any other resource that can be accessed over the Internet.</p>
                        <p>Here are some examples of URIs:</p>
                        <ul>
                            <li>https://www.example.com: This is the URI for the homepage of a website named "example.com". It uses the HTTPS protocol to encrypt communication between the client and server.</li>
                            <li>ftp://ftp.example.com/pub/file.txt: This is the URI for a file named "file.txt" located in a directory named "pub" on an FTP server named "ftp.example.com". It uses the FTP protocol to transfer files between the client and server.</li>
                            <li>mailto:user@example.com: This is the URI for an email address "user@example.com". When a user clicks on a link with this URI, it will open their default email client and create a new email addressed to "user@example.com".</li>
                            <li>tel:+1-123-456-7890: This is the URI for a phone number. When a user clicks on a link with this URI, it will open their default phone application and dial the number.</li>
                            <li>data:text/plain;base64,SGVsbG8gV29ybGQ=: This is the URI for a data URL that contains a base64-encoded string of text. When a user clicks on a link with this URI, it will display the text "Hello World" in the browser.</li>
                        </ul>
                        <p>In summary, a URI is a string of characters that identifies a resource on the Internet. It can be used to access web pages, files, email addresses, phone numbers, and other resources.</p>
                    </div>

                    <div>
                        <h1>URL</h1>
                        <p>A URL stands for Uniform Resource Locator. It is a type of URI that specifies the address of a resource on the internet. A URL consists of several components, including the protocol, domain name, path, and query parameters.</p>
                        <p>Here are some examples of URLs:</p>
                        <ul>
                            <li>https://www.google.com: This is the URL for the homepage of the Google search engine. It uses the HTTPS protocol to encrypt communication between the client and server.</li>
                            <li>http://www.example.com/page1.html: This is the URL for a web page named "page1.html" located on a website named "example.com". It uses the HTTP protocol to transfer data between the client and server.</li>
                            <li>ftp://ftp.example.com/file.txt: This is the URL for a file named "file.txt" located on an FTP server named "ftp.example.com". It uses the FTP protocol to transfer files between the client and server.</li>
                            <li>mailto:user@example.com: This is the URL for an email address "user@example.com". When a user clicks on a link with this URL, it will open their default email client and create a new email addressed to "user@example.com".</li>
                            <li>tel:+1-123-456-7890: This is the URL for a phone number. When a user clicks on a link with this URL, it will open their default phone application and dial the number.</li>
                            <li>https://www.example.com/search?q=example: This is the URL for a search query for the keyword "example" on the website named "example.com". It includes a query parameter "q" with the value "example".</li>
                        </ul>
                        <p>In summary, a URL is a type of URI that specifies the address of a resource on the internet. It can be used to access web pages, files, email addresses, phone numbers, and other resources.</p>
                    </div>

                    <div>
                        <h1>difference between URI and URL with examples</h1>
                        <p>URI (Uniform Resource Identifier) and URL (Uniform Resource Locator) are related concepts, but they are not the same thing. A URL is a type of URI that specifies the location of a resource on the internet.</p>
                        <p>Here's the difference between URI and URL:</p>
                        <ul>
                            <li>URI is a string of characters that identifies the name or a resource on the internet.</li>
                            <li>URL is a type of URI that specifies the location of a resource on the internet.</li>
                        </ul>
                        <p>Here are some examples to illustrate the difference:</p>
                        <ul>
                            <li>mailto:user@example.com: This is a URI that identifies an email address "user@example.com". It is not a URL because it doesn't specify the location of any resource on the internet.</li>
                            <li>https://www.example.com: This is a URL that specifies the location of the homepage of the website "example.com". It is also a URI because it identifies the resource.</li>
                            <li>http://www.example.com/search?q=example: This is a URL that specifies the location of a search query for the keyword "example" on the website "example.com". It is also a URI because it identifies the resource.</li>
                        </ul>
                        <p>In summary, a URL is a type of URI that specifies the location of a resource on the internet. URI is a more general term that can identify any resource on the internet, not just its location.</p>
                    </div>

                    <div id="WhyAPITesting">
                        <h1>API Testing: What It Is, Why It’s Important & How to Do It</h1>
                        <p>The global API testing market is projected to reach 1.8 billion USD by 2026, up from 641.6
                            Million in 2020, according to a report by Global Industry Analysts Inc.</p>
                        <p>This market growth corresponds to the rise in cloud applications and interconnected platforms
                            that require application programming interfaces (APIs). More APIs mean more testing to
                            determine that they meet expectations for functionality, reliability, performance, and
                            security. Without this testing, an API may fail to perform as expected, which can impact
                            many softwares and services.</p>
                        <p>please refer the following links</p>
                        <ul>
                            <li><a
                                    href="https://www.prnewswire.com/news-releases/global-industry-analysts-predicts-the-world-api-testing-market-to-reach-1-8-billion-by-2026--301364974.html">Global
                                    Industry Analysts Predicts the World API Testing Market to Reach $1.8 Billion by
                                    2026</a></li>
                            <li><a
                                    href="https://www.strategyr.com/market-report-api-testing-forecasts-global-industry-analysts-inc.asp">API
                                    Testing World market report MCP 10331</a></li>
                        </ul>
                        <h2>What is API testing?</h2>
                        <p>API testing is the process of sending requests to an API and monitoring the responses to
                            ensure its behaving as expected. API testing is designed to assess the functionality,
                            reliability, performance, and security of an API, and is therefore an essential part of the
                            API development lifecycle.</p>
                        <p>Software application development is dominated by the three-layered architecture approach,
                            which is an architecture made up of a presentation layer, business logic layer, and database
                            layer.</p>
                        <img src="./images/API Testing-2.jpg" alt="api testing" width="100%">
                        <p>The business logic layer contains the core functionality, or components, of the application.
                            It must take information inputted by the user from the presentation layer, query the
                            database layer and transform that data according to the business logic, and present the
                            results back to the user via the presentation layer. But the business logic layer must also
                            communicate with other applications as well as human users. To do so, it uses an API.</p>
                        <img src="./images/API Testing3.jpg" alt="api testing" width="100%">
                        <p>So API testing is designed to validate the business logic as well as the performance,
                            security, and other aspects of the application. API testing does not focus on the individual
                            components of an application, like unit testing, or the look and feel of the application,
                            like user interface (UI) testing, but on what the application does.</p>
                        <img src="./images/API Testing4.jpg" alt="api testing" width="100%">
                        <h4>Types of API Testing</h4>
                        <ul>
                            <li>API Documentation testing</li>
                            <li>Functional testing. These API tests are designed to check that an API returns the right
                                response for a given request.</li>
                            <li>Load testing. This type of API test gauges how an API handles a large volume of requests
                                over a short period.</li>
                            <li>Runtime and error detection testing. These API tests are designed to evaluate the actual
                                running of the API and typically focus on monitoring, execution errors, resource leaks,
                                or error detection.</li>
                            <li>Security testing. These tests assess how an API responds to and resists cyberattacks.
                            </li>
                            <li>Penetration Testing. Penetration tests involve users with limited API knowledge trying
                                to attack the API, which enables testers to assess the threat vector from an outside
                                perspective.</li>
                            <li>Fuzz Testing. This type of API test sends a large number of randomized requests to see
                                if your API responds with errors, processes any of these inputs incorrectly, or crashes.
                            </li>
                            <li>Validation testing. Validation tests are run late in the testing stage to verify the
                                behavior and efficiency of the API.</li>
                        </ul>
                        <h4>Why is API testing important?</h4>
                        <p>API testing is important for ensuring that your API performs as expected when faced with a
                            wide variety of expected and unexpected requests. This process is designed to not only test
                            the API’s functionality — but also its reliability, performance, and security.</p>
                        <p>API testing is also important because it offers several advantages over other types of
                            testing, like unit and UI testing.</p>
                        <p>For example, unit tests are designed to verify the functionality of individual components
                            within a single application whereas API tests are designed to verify that all system
                            components function as intended. This broader test coverage makes it easier to identify any
                            bugs in the unit, database, and server levels.</p>
                        <p>API tests are also faster to run and more isolated than UI tests, which makes it quicker and
                            easier to identify and resolve bugs. According to data from Andersen Lab, a UI test runs for
                            approximately seven minutes while an API test runs for 12 seconds. Meaning, an API test is
                            about 35 times faster than a UI test.</p>
                        <p>Perhaps most importantly, API testing allows developer operations, quality assurance,
                            development, and other teams to begin testing an application’s core functionality before the
                            user interface is ready. This enables them to identify any errors or weaknesses early on in
                            the development process. If identified later in the process, these errors and weaknesses in
                            the build can be costly to fix, requiring large amounts of code to be rewritten and
                            significantly delaying the product’s release.</p>
                        <h4>How to Do API Testing</h4>
                        <h5>1. Review the API specification.</h5>
                        <p>Before you start testing, you need to first understand the purpose of the API, how the API
                            functions, and what results to expect when using the API. To do so, you can review the API
                            specification.</p>
                        <p>For example, if you’re testing an HTTP API, then you can review the OpenAPI specification,
                            which defines a standard, programming language-agnostic interface description for HTTP APIs.
                            This specification details all the HTTP API’s objects, values, and parameters, how the
                            objects are called, what each object does, and how they can be used together. The section
                            below details how the Request Body Object is supposed to function, what its fixed fields
                            are, what to expect when using this function, and request body examples.</p>
                        <h5>2. Determine API testing requirements.</h5>
                        <p>Next, you need to determine the testing requirements of the API. This will require you to
                            understand the API’s target consumer, its features and functions, and the workflow of the
                            application as well as the aspects, priorities, and problems you’re testing for. For
                            example, maybe you want to verify that HTTP headers are as expected or that a response is
                            received within a reasonable period of time, as defined by the test plan.</p>
                        <p>You’ll also need to know the desired output — which could be a 2XX HTTP status code or a JSON
                            object, for example.</p>
                        <h5>3. Define input parameters.</h5>
                        <p>Before calling an API, you must define input parameters. These parameters pass needed
                            information to the API to enable it to perform its function and therefore are necessary for
                            determining whether the API performs as expected. For example, a REST API can accept header,
                            query, and rest body parameters, among other input parameter types.</p>
                        <p>Before beginning API testing, it’s important to plan out all possible input combinations.</p>
                        <h5>4. Create positive and negative tests.</h5>
                        <p>To assess whether an API functions as expected, you should run a combination of positive and
                            negative tests.</p>
                        <p>Positive tests are designed to check the basic functionality of the API using required
                            parameters as well as extra functionality using optional parameters.</p>
                        <p>Negative tests are designed to check how the API responds to prohibited operations using
                            valid and invalid user input, like trying to input a username that already exists or a
                            username that is null.</p>
                        <h5>5. Select an API testing tool.</h5>
                        <p>Now you’re ready to select an API testing tool that can help automate or simplify the API
                            testing process. When evaluating different API testing tools, it’s important to know what
                            kind of API you’ll be testing, what kind of tests you’ll be running, and what your budget
                            is.</p>
                        <h2>10 Best API Testing Tools for Building Functional, Secure Applications</h2>
                        <ul>
                            <li>Postman</li>
                            <li>KarateDSL</li>
                            <li>Rest Assured</li>
                            <li>SoapUI</li>
                            <li>Fiddler</li>
                            <li>Katalon Studio</li>
                            <li>Assertible</li>
                            <li>Tricentis Tosca</li>
                            <li>Swagger</li>
                            <li>Apache JMeter</li>
                        </ul>
                        <p>for more info please refer <a href="https://blog.hubspot.com/website/api-testing">API
                                Testing: What It Is, Why It’s Important & How to Do It</a></p>
                    </div>

                    <div id="WhatisanAPI">
                        <h1>What is an API? (Application Programming Interface)</h1>
                        <p>API is the acronym for Application Programming Interface, which is a software intermediary
                            that allows two applications to talk to each other. Each time you use an app like Facebook,
                            send an instant message, or check the weather on your phone, you’re using an API.</p>
                        <h2>What Is an Example of an API?</h2>
                        <p>When you use an application on your mobile phone, the application connects to the Internet
                            and sends data to a server. The server then retrieves that data, interprets it, performs the
                            necessary actions and sends it back to your phone. The application then interprets that data
                            and presents you with the information you wanted in a readable way. This is what an API is -
                            all of this happens via API.</p>
                        <p>Imagine you’re sitting at a table in a restaurant with a menu of choices to order from. The
                            kitchen is the part of the “system” that will prepare your order. What is missing is the
                            critical link to communicate your order to the kitchen and deliver your food back to your
                            table. That’s where the waiter or API comes in. The waiter is the messenger – or API – that
                            takes your request or order and tells the kitchen – the system – what to do. Then the waiter
                            delivers the response back to you; in this case, it is the food.</p>
                        <p>Here is a real-life API example. You may be familiar with the process of searching flights
                            online. Just like the restaurant, you have a variety of options to choose from, including
                            different cities, departure and return dates, and more. Let us imagine that you’re booking
                            you are flight on an airline website. You choose a departure city and date, a return city
                            and date, cabin class, as well as other variables. In order to book your flight, you
                            interact with the airline’s website to access their database and see if any seats are
                            available on those dates and what the costs might be.</p>

                    </div>

                    <div id="WhatisREST">
                        <h1>What is REST?</h1>
                        <p>Representational state transfer is a software architectural style that describes a uniform
                            interface between physically separate components, often across the Internet in a
                            Client-Server architecture. ---Wikipedia</p>
                        <p>REST stands for Representational State Transfer, a term coined by Roy Fielding in 2000. It is
                            an architecture style for designing loosely coupled applications over the network, that is
                            often used in the development of web services.</p>
                        <p>REST does not enforce any rule regarding how it should be implemented at the lower level, it
                            just put high-level design guidelines and leaves us to think of our own implementation.</p>
                        <img src="./images/Rest-API.png" alt="rest api" width="100%">
                    </div>

                    <div id="ArchitecturalConstraints">
                        <h1>Architectural Constraints</h1>
                        <p>REST defines 6 architectural constraints which make any web service – a truly RESTful API.
                        </p>
                        <ul>
                            <li>Uniform interface</li>
                            <li>Client–server</li>
                            <li>Stateless</li>
                            <li>Cacheable</li>
                            <li>Layered system</li>
                            <li>Code on demand (optional)</li>
                        </ul>
                        <h2>Uniform interface</h2>
                        <p>A resource in the system should have only one logical URI, and that should provide a way to
                            fetch related or additional data.</p>
                        <p>Any single resource should not be too large and contain each and everything in its
                            representation. Whenever relevant, a resource should contain links (HATEOAS) pointing to
                            relative URIs to fetch related information.</p>
                        <h2>Client–server</h2>
                        <H5>What uis client?</H5>
                        <p>A client is a computer hardware or software that access a service made available by a server.
                        </p>
                        <h5>What is server?</h5>
                        <p>A server is a physical computer dedicated to run services to server the needs of the
                            coputers. Depending on the service that is running it colud be a File server,database
                            server, print server and web server.</p>
                        <p>This constraint essentially means that client applications and server applications MUST be
                            able to evolve separately without any dependency on each other. A client should know only
                            resource URIs, and that’s all. Today, this is standard practice in web development, so
                            nothing fancy is required from your side. Keep it simple.</p>
                        <p>Servers and clients may also be replaced and developed independently, as long as the
                            interface between them is not altered.</p>
                        <h2>Stateless</h2>
                        <img src="./images/ghajini.jpg" alt="ghajini" width="100%">
                        <p>Make all client-server interactions stateless. The server will not store anything about the
                            latest HTTP request the client made. It will treat every request as new. No session, no
                            history.</p>
                        <p>If the client application needs to be a stateful application for the end-user, where the user
                            logs in once and does other authorized operations after that, then each request from the
                            client should contain all the information necessary to service the request – including
                            authentication and authorization details.</p>
                        <p>No client context shall be stored on the server between requests. The client is responsible
                            for managing the state of the application.</p>
                        <h2>Cacheable</h2>
                        <img src="./images/ghajini2.jpg" alt="ghajini" width="100%">
                        <p>In today’s world, the caching of data and responses is of utmost importance wherever they are
                            applicable/possible. Caching brings performance improvement for the client-side and better
                            scope for scalability for a server because the load has been reduced.</p>
                        <p>In REST, caching shall be applied to resources when applicable, and then these resources MUST
                            declare themselves cacheable. Caching can be implemented on the server or client-side.</p>
                        <p>Well-managed caching partially or completely eliminates some client-server interactions,
                            further improving scalability and performance.</p>
                        <h2>Layered system</h2>
                        <img src="./images/rest_api_layered_system.png" alt="rest api layered system" width="100%">
                        <p>REST allows you to use a layered system architecture where you deploy the APIs on server A,
                            and store data on server B and authenticate requests in Server C, for example. A client
                            cannot ordinarily tell whether it is connected directly to the end server or an intermediary
                            along the way.</p>
                        <h2>Code on demand (optional)</h2>
                        <p>Well, this constraint is optional. Most of the time, you will be sending the static
                            representations of resources in the form of XML or JSON. But when you need to, you are free
                            to return executable code to support a part of your application, e.g., clients may call your
                            API to get a UI widget rendering code. It is permitted.</p>
                        <pre>
                                <p>URI examples</p>
                                <code>
http://www.appdomain.com/users
http://www.appdomain.com/users?size=20&page=5
http://www.appdomain.com/users/123
http://www.appdomain.com/users/123/address
                                </code>
                            </pre>
                        <p>refer the <a href="https://restfulapi.net/rest-architectural-constraints/">link</a></p>
                    </div>

                    <div id="HTTPrequestmethods">
                        <h1>HTTP request methods</h1>
                        <p>HTTP defines a set of request methods to indicate the desired action to be performed for a
                            given resource. Although they can also be nouns, these request methods are sometimes
                            referred to as HTTP verbs. Each of them implements a different semantic, but some common
                            features are shared by a group of them: e.g. a request method can be safe, idempotent, or
                            cacheable.</p>
                        <h2>GET</h2>
                        <p>The GET method requests a representation of the specified resource. Requests using GET should
                            only retrieve data.</p>
                        <h4>Syntax</h4>
                        <pre>
                                <code>
GET /index.html
                                </code>
                            </pre>
                        <h2>HEAD</h2>
                        <p>The HTTP HEAD method requests the headers that would be returned if the HEAD request's URL
                            was instead requested with the HTTP GET method. For example, if a URL might produce a large
                            download, a HEAD request could read its Content-Length header to check the filesize without
                            actually downloading the file.</p>
                        <p><b>Warning:</b> A response to a HEAD method should not have a body. If it has one anyway,
                            that body must be ignored: any representation headers that might describe the erroneous body
                            are instead assumed to describe the response which a similar GET request would have
                            received.</p>
                        <h4>Syntax</h4>
                        <pre>
                                <code>
HEAD /index.html
                                </code>
                            </pre>
                        <h2>POST</h2>
                        <p>The POST method submits an entity to the specified resource, often causing a change in state
                            or side effects on the server.</p>
                        <p>The HTTP POST method sends data to the server. The type of the body of the request is
                            indicated by the Content-Type header.</p>
                        <p>The difference between PUT and POST is that PUT is idempotent: calling it once or several
                            times successively has the same effect (that is no side effect), where successive identical
                            POST may have additional effects, like passing an order several times.</p>
                        <p>A POST request is typically sent via an HTML form and results in a change on the server. In
                            this case, the content type is selected by putting the adequate string in the enctype
                            attribute of the &lt;form&gt; element or the formenctype attribute of the &lt;input&gt; or
                            &lt;button&gt; elements:</p>
                        <ul>
                            <li>application/x-www-form-urlencoded: the keys and values are encoded in key-value tuples
                                separated by '&', with a '=' between the key and the value. Non-alphanumeric characters
                                in both keys and values are percent encoded: this is the reason why this type is not
                                suitable to use with binary data (use multipart/form-data instead)</li>
                            <li>multipart/form-data: each value is sent as a block of data ("body part"), with a user
                                agent-defined delimiter ("boundary") separating each part. The keys are given in the
                                Content-Disposition header of each part.</li>
                            <li>text/plain</li>
                        </ul>
                        <p>When the POST request is sent via a method other than an HTML form — like via an
                            XMLHttpRequest — the body can take any type. As described in the HTTP 1.1 specification,
                            POST is designed to allow a uniform method to cover the following functions:</p>
                        <ul>
                            <li>Annotation of existing resources</li>
                            <li>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of
                                articles;</li>
                            <li>Adding a new user through a signup modal;</li>
                            <li>Providing a block of data, such as the result of submitting a form, to a data-handling
                                process;</li>
                            <li>Extending a database through an append operation.</li>
                        </ul>
                        <p>A simple form using the default application/x-www-form-urlencoded content type:</p>
                        <pre>
                                <code>
POST /test HTTP/1.1
Host: foo.example
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

field1=value1&field2=value2
                                </code>
                            </pre>
                        <p>A form using the multipart/form-data content type:</p>
                        <pre>
                                <code>
POST /test HTTP/1.1
Host: foo.example
Content-Type: multipart/form-data;boundary="boundary"

--boundary
Content-Disposition: form-data; name="field1"

value1
--boundary
Content-Disposition: form-data; name="field2"; filename="example.txt"

value2
--boundary--
                                </code>
                            </pre>
                        <h2>PUT</h2>
                        <p>The HTTP PUT request method creates a new resource or replaces a representation of the target
                            resource with the request payload.</p>
                        <p>The difference between PUT and POST is that PUT is idempotent: calling it once or several
                            times successively has the same effect (that is no side effect), whereas successive
                            identical POST requests may have additional effects, akin to placing an order several times.
                        </p>
                        <h4>Syntax</h4>
                        <pre>
                                <code>
PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

&lt;p&gt;New File&lt;/p&gt;
                                </code>
                            </pre>
                        <h4>Responses</h4>
                        <p>If the target resource does not have a current representation and the PUT request
                            successfully creates one, then the origin server must inform the user agent by sending a 201
                            (Created) response.</p>
                        <pre>
                                <code>
HTTP/1.1 201 Created
Content-Location: /new.html
                                </code>
                            </pre>
                        <p>If the target resource does have a current representation and that representation is
                            successfully modified in accordance with the state of the enclosed representation, then the
                            origin server must send either a 200 (OK) or a 204 (No Content) response to indicate
                            successful completion of the request.</p>
                        <pre>
                                <code>
HTTP/1.1 204 No Content
Content-Location: /existing.html
                                </code>
                            </pre>
                        <h2>DELETE</h2>
                        <p> The HTTP DELETE request method deletes the specified resource. </p>
                        <h4>Syntax</h4>
                        <pre>
                                <code>
DELETE /file.html HTTP/1.1
                                </code>
                            </pre>
                        <h4>Request</h4>
                        <pre>
                                <code>
DELETE /file.html HTTP/1.1
Host: example.com
                                </code>
                            </pre>
                        <h4>Response</h4>
                        <p> If a DELETE method is successfully applied, there are several response status codes
                            possible: </p>
                        <ul>
                            <li> A 202 (Accepted) status code if the action will likely succeed but has not yet been
                                enacted. </li>
                            <li> A 204 (No Content) status code if the action has been enacted and no further
                                information is to be supplied. </li>
                            <li> A 200 (OK) status code if the action has been enacted and the response message includes
                                a representation describing the status. </li>
                        </ul>
                        <h2>PATCH</h2>
                        <p>The HTTP PATCH request method applies partial modifications to a resource.</p>
                        <p>PATCH is somewhat analogous to the "update" concept found in CRUD (in general, HTTP is
                            different than CRUD, and the two should not be confused).</p>
                        <p>A PATCH request is considered a set of instructions on how to modify a resource. Contrast
                            this with PUT; which is a complete representation of a resource.</p>
                        <p>A PATCH is not necessarily idempotent, although it can be. Contrast this with PUT; which is
                            always idempotent. The word "idempotent" means that any number of repeated, identical
                            requests will leave the resource in the same state. For example if an auto-incrementing
                            counter field is an integral part of the resource, then a PUT will naturally overwrite it
                            (since it overwrites everything), but not necessarily so for PATCH.</p>
                        <h4>Request</h4>
                        <pre>
                                <code>
PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100

[description of changes]
                                </code>
                            </pre>
                        <h4>Response</h4>
                        <pre>
                                <code>
HTTP/1.1 204 No Content
Content-Location: /file.txt
ETag: "e0023aa4f"
                                </code>
                            </pre>
                    </div>

                    <div id="HTTPresponsestatuscodes">
                        <h1>HTTP response status codes</h1>
                        <p> HTTP response status codes indicate whether a specific HTTP request has been successfully
                            completed. Responses are grouped in five classes: </p>
                        <ul>
                            <li>Information responses(100-199)</li>
                            <li>Successful responses(200-299)</li>
                            <li>Redirection messages(300-399)</li>
                            <li>Client error responses(400-499)</li>
                            <li>Server error responses(500-599)</li>
                        </ul>
                        <h2>Successful responses</h2>
                        <h4>200 OK</h4>
                        <p>The request succeeded. The result meaning of "success" depends on the HTTP method:</p>
                        <ul>
                            <li>GET: The resource has been fetched and transmitted in the message body.</li>
                            <li>HEAD: The representation headers are included in the response without any message body.
                            </li>
                            <li>PUT or POST: The resource describing the result of the action is transmitted in the
                                message body.</li>
                            <li>TRACE: The message body contains the request message as received by the server.</li>
                        </ul>
                        <h4>201 Created</h4>
                        <p>The request succeeded, and a new resource was created as a result. This is typically the
                            response sent after POST requests, or some PUT requests.</p>
                        <h4>202 Accepted</h4>
                        <p>The request has been received but not yet acted upon. It is noncommittal, since there is no
                            way in HTTP to later send an asynchronous response indicating the outcome of the request. It
                            is intended for cases where another process or server handles the request, or for batch
                            processing.</p>
                        <h4>204 No Content</h4>
                        <p>There is no content to send for this request, but the headers may be useful. The user agent
                            may update its cached headers for this resource with the new ones.</p>
                        <h2>Redirection messages</h2>
                        <h4>301 Moved Permanently</h4>
                        <p>The URL of the requested resource has been changed permanently. The new URL is given in the
                            response.</p>
                        <h4>302 Found</h4>
                        <p>This response code means that the URI of requested resource has been changed temporarily.
                            Further changes in the URI might be made in the future. Therefore, this same URI should be
                            used by the client in future requests.</p>
                        <h2>Client error responses</h2>
                        <h4>400 Bad Request</h4>
                        <p>The server cannot or will not process the request due to something that is perceived to be a
                            client error (e.g., malformed request syntax, invalid request message framing, or deceptive
                            request routing).</p>
                        <h4>401 Unauthorized</h4>
                        <p>Although the HTTP standard specifies "unauthorized", semantically this response means
                            "unauthenticated". That is, the client must authenticate itself to get the requested
                            response.</p>
                        <h4>403 Forbidden</h4>
                        <p>The client does not have access rights to the content; that is, it is unauthorized, so the
                            server is refusing to give the requested resource. Unlike 401 Unauthorized, the client's
                            identity is known to the server.</p>
                        <h4>404 Not Found</h4>
                        <p>The server can not find the requested resource. In the browser, this means the URL is not
                            recognized. In an API, this can also mean that the endpoint is valid but the resource itself
                            does not exist. Servers may also send this response instead of 403 Forbidden to hide the
                            existence of a resource from an unauthorized client. This response code is probably the most
                            well known due to its frequent occurrence on the web.</p>
                        <h4>405 Method Not Allowed</h4>
                        <p>The request method is known by the server but is not supported by the target resource. For
                            example, an API may not allow calling DELETE to remove a resource.</p>
                        <h4>408 Request Timeout</h4>
                        <p>This response is sent on an idle connection by some servers, even without any previous
                            request by the client. It means that the server would like to shut down this unused
                            connection. This response is used much more since some browsers, like Chrome, Firefox 27+,
                            or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers
                            merely shut down the connection without sending this message.</p>
                        <h4>409 Conflict</h4>
                        <p>This response is sent when a request conflicts with the current state of the server.</p>
                        <h4>411 Length Required</h4>
                        <p>Server rejected the request because the Content-Length header field is not defined and the
                            server requires it.</p>
                        <h4>422 Unprocessable Entity</h4>
                        <p>The request was well-formed but was unable to be followed due to semantic errors.</p>
                        <h4>429 Too Many Requests</h4>
                        <p>The user has sent too many requests in a given amount of time ("rate limiting").</p>
                        <h2>Server error responses</h2>
                        <h4>500 Internal Server Error</h4>
                        <p>The server has encountered a situation it does not know how to handle.</p>
                        <h4>502 Bad Gateway</h4>
                        <p>This error response means that the server, while working as a gateway to get a response
                            needed to handle the request, got an invalid response.</p>
                        <h4>503 Service Unavailable</h4>
                        <p>The server is not ready to handle the request. Common causes are a server that is down for
                            maintenance or that is overloaded. Note that together with this response, a user-friendly
                            page explaining the problem should be sent. This response should be used for temporary
                            conditions and the Retry-After HTTP header should, if possible, contain the estimated time
                            before the recovery of the service. The webmaster must also take care about the
                            caching-related headers that are sent along with this response, as these temporary condition
                            responses should usually not be cached.</p>
                        <h4>504 Gateway Timeout</h4>
                        <p>This error response is given when the server is acting as a gateway and cannot get a response
                            in time.</p>
                        <p>for complete list of <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HTTP
                                status codes</a></p>
                    </div>

                    <div>
                        <h1>URI vs URL | Difference between URI and URL</h1>
                        <h4>What is URI?</h4>
                        <p>A URI or Uniform Resource Identifier is a string identifier that refers to a resource on the
                            internet. It is a string of characters that is used to identify any resource on the internet
                            using location, name, or both.

                            A URI has two subsets; URL (Uniform Resource Locator) and URN (Uniform Resource Number). If
                            it contains only a name, it means it is not a URL. Instead of directly URI, we mostly see
                            the URL and URN in the real world.</p>
                        <h5>Some examples of URI</h5>
                        <ul>
                            <li>mailto:hey.Doe@example.com</li>
                            <li>news:comp.infosystems.www.servers.unix</li>
                            <li>urn:oasis:names:specification:docbook:dtd:xml:4.1.2</li>
                        </ul>
                        <h4>What is the URL?</h4>
                        <p>A URL or Uniform Resource Locator is used to find the location of the resource on the web. It
                            is a reference for a resource and a way to access that resource. A URL always shows a unique
                            resource, and it can be an HTML page, a CSS document, an image, etc.

                            A URL uses a protocol for accessing the resource, which can be HTTP, HTTPS, FTP, etc.

                            It is mainly referred to as the address of the website, which a user can find in their
                            address bars.</p>
                        <p>Note: All URLs can be URIs, but all URIs cannot be URLs. It is because a URI contains both
                            URL and URN and represent URL or URN, or both.</p>
                        <img src="./images/urlVSuri1.png" alt="url vs uri" width="100%">
                        <img src="./images/urlVSuri2.jpg" alt="url vs uri" width="100%">
                        <table>
                            <tr>
                                <th>URI</th>
                                <th>URL</th>
                            </tr>
                            <tr>
                                <td>URI is an acronym for Uniform Resource Identifier.</td>
                                <td>URL is an acronym for Uniform Resource Locator.</td>
                            </tr>
                            <tr>
                                <td>URI contains two subsets, URN, which tell the name, and URL, which tells the
                                    location.</td>
                                <td>URL is the subset of URI, which tells the only location of the resource.</td>
                            </tr>
                            <tr>
                                <td>All URIs cannot be URLs, as they can tell either name or location.</td>
                                <td>All URLs are URIs, as every URL can only contain the location.</td>
                            </tr>
                            <tr>
                                <td>A URI aims to identify a resource and differentiate it from other resources by using
                                    the name of the resource or location of the resource.</td>
                                <td>A URL aims to find the location or address of a resource on the web.</td>
                            </tr>
                            <tr>
                                <td>An example of a URI can be ISBN 0-486-35557-4.</td>
                                <td>An example of an URL is https://www.javatpoint.com.</td>
                            </tr>
                            <tr>
                                <td>It is commonly used in XML and tag library files such as JSTL and XSTL to identify
                                    the resources and binaries.</td>
                                <td>It is mainly used to search the webpages on the internet.</td>
                            </tr>
                            <tr>
                                <td>The URI scheme can be protocol, designation, specification, or anything.</td>
                                <td>The scheme of URL is usually a protocol such as HTTP, HTTPS, FTP, etc.</td>
                            </tr>
                        </table>
                    </div>

                    <div>

                    </div>
                </div>
            </div>
        </div>
    </article>
    <!-- Footer-->
    <footer class="border-top">
        <div class="container px-4 px-lg-5">
            <div class="row gx-4 gx-lg-5 justify-content-center">
                <div class="col-md-10 col-lg-8 col-xl-7">
                    <ul class="list-inline text-center">
                        <li class="list-inline-item">
                            <a href="#!">
                                <span class="fa-stack fa-lg">
                                    <i class="fas fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li class="list-inline-item">
                            <a href="#!">
                                <span class="fa-stack fa-lg">
                                    <i class="fas fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-facebook-f fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li class="list-inline-item">
                            <a href="#!">
                                <span class="fa-stack fa-lg">
                                    <i class="fas fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                    <div class="small text-center text-muted fst-italic">Copyright &copy; Your Website 2022</div>
                </div>
            </div>
        </div>
    </footer>
    <!-- Bootstrap core JS-->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Core theme JS-->
    <script src="js/scripts.js"></script>
</body>

</html>